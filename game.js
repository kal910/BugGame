/**
 * @type {{
 * enemyData: {rows:number, columns:number, velocity: number}
 * }}
 */
const enemyData = {
  rows: 3,
  columns: 8,
  velocity: 100
};

/**
 * @type {Phaser.Types.GameObjects.Text.TextStyle}
 */
const textStyle = { fontSize: '15px', fill: '#000000' };

class GameScene extends Phaser.Scene {

  preload() {
    this.load.image('bug1', 'images/bug_1.png');
    this.load.image('bug2', 'images/bug_2.png');
    this.load.image('bug3', 'images/bug_3.png');
    this.load.image('platform', 'images/platform.png');
    this.load.image('codey', 'images/codey.png');
    this.load.image('bugPellet', 'images/bugPellet.png');
    this.load.image('bugRepellent', 'images/bugRepellent.png');
  }

  // returns an array of enemy sprites sorted by their x coordinate
  sortedEnemies() {
    const orderedByXCoord = this.enemies.getChildren().sort((a, b) => a.x - b.x);
    return orderedByXCoord;
  }

  numOfTotalEnemies() {
    return this.enemies.getChildren().length;
  }

  create() {
    // When this.active is true, the game is being played and not over. 
    // When this.active is false, then it's game over.
    this.active = true;

    // Creates cursor objects to be used in update()
    //this.cursors = this.input.keyboard.createCursorKeys();

    // We want WASD also alongside other keys generated by createCursorKeys, so use this instead.
    this.cursors = this.input.keyboard.addKeys('up,down,left,right,space,shift,W,A,S,D');

    // When this.active is false, the game will listen for a pointerup event and restart when the event happens
    this.input.on('pointerup', () => {
      if (this.active === false) {   //note: use triple equal
        this.scene.restart();
      }
    })

    // Creating static platforms
    const platforms = this.physics.add.staticGroup();
    //platforms.create(225, 490, 'platform').setScale(1, .3).refreshBody();
    platforms.create(config.width / 2, config.height * 0.98, 'platform').setScale(1, 0.3).refreshBody();

    this.enemies = this.physics.add.group();
    let { rows, columns } = enemyData;
    for (let yVal = 1; yVal <= rows; yVal++) {
      for (let xVal = 1; xVal <= columns; xVal++) {
        let bug = this.enemies.create(50 * xVal, 50 * yVal, 'bug1').setScale(.6);
      }
    }

    // Displays the initial number of bugs, this value is initially hardcoded as 24 
    this.scoreText = this.add.text(175, 482, `Bugs Left: ${this.numOfTotalEnemies()}`, textStyle);

    // Uses the physics plugin to create Codey
    this.player = this.physics.add.sprite(225, 450, 'codey').setScale(.5);

    // Create Collider objects
    this.player.setCollideWorldBounds(true);
    this.physics.add.collider(this.player, platforms);

    this.enemyPellets = this.physics.add.group();
    // lambda expression
    const genEnemyPellet = () => {
      let children = this.enemies.getChildren();
      let randomBug = Phaser.Utils.Array.GetRandom(children);
      let enemyPellet = this.enemyPellets.create(randomBug.x, randomBug.y, 'bugPellet');
      // TASK:
      // Make enemy pellets drop towards player.
      enemyPellet.setGravityY(200);

    
    }

    this.pelletsSpawnTimer = this.time.addEvent({
      delay: 300,
      callback: genEnemyPellet,
      callbackScope: this,
      loop: true,
    })

    this.physics.add.collider(this.enemyPellets, platforms, (pellet) => pellet.destroy())
    this.physics.add.collider(this.enemyPellets, this.player, () => this.gameOverState())

    this.bugRepellents = this.physics.add.group();

    // TASK:
    // Add physics collider check for enemies and bugRepellents
    // If collide, destroy both.
    // Then update scoreText using
    // this.scoreText.setText(`Bugs Left: ${this.numOfTotalEnemies()}`)

    //this.physics.add.collider(this.enemies, this.player, (bug, player) => this.gameOverState())
    this.physics.add.collider(this.enemies, this.bugRepellents, (bug, repellent) => 
    {
      bug.destroy();
      repellent.destroy();
      this.scoreText.setText (
        `Bugs left: ${this.numOfTotalEnemies()}`) 
      
    });
    
   // this.recordedTime = 0;
  }
    
  

  gameOverState() {
    this.active = false;
    this.pelletsSpawnTimer.destroy();
    enemyData.velocity = 100;
    this.physics.pause();
    this.add.text(180, 250, 'Game Over!\nClick to restart', textStyle);
  }

  winningState() {
    this.active = false;
    this.pelletsSpawnTimer.destroy();
    enemyData.velocity = 100;
    this.physics.pause();
    this.add.text(180, 250, 'You Won!!\nClick to restart', textStyle);
  }

  //(   ) => {
  //     Lamda expression
  //    function BODY
  // }

  update(time, delta) {

    // time and delta is in milliseconds, so divide by 1000 to convert to seconds
    let deltaTime = delta / 1000;

    if (this.active) {
      // If the game is active, then players can control Codey
      if (this.cursors.left.isDown || this.cursors.A.isDown) {
        this.player.setVelocityX(-160);
      } else if (this.cursors.right.isDown || this.cursors.D.isDown) {
        this.player.setVelocityX(160);
      } else if (this.cursors.up.isDown || this.cursors.W.isDown) {
        this.player.setVelocityY(-160);
      } else if (this.cursors.down.isDown || this.cursors.S.isDown) {
      this.player.setVelocityY(160);
      } else  {
        this.player.setVelocityX(0); 
        this.player.setVelocityY(0);//to stop moving the guy
      }
      // Execute code if the spacebar key is pressed
      if (Phaser.Input.Keyboard.JustDown(this.cursors.space)) {
        let repellent = this.bugRepellents.create(this.player.x, this.player.y, 'bugRepellent');
        repellent.setGravityY(-300);
      }

      
      // logic for winning condition and enemy movements below:
      if (this.numOfTotalEnemies() === 0) {
        this.winningState();
      }
      else {
        this.enemies.getChildren().forEach((bug) => {
          // Note that the bugs move using this approach instead of setVelocity!
          bug.x += enemyData.velocity * deltaTime;
        })

        const enemiesSorted = this.sortedEnemies();
        const leftMostBug = enemiesSorted[0];
        const rightMostBug = enemiesSorted[enemiesSorted.length - 1];
        if (leftMostBug.x < 10 || rightMostBug.x > 440) {
          enemyData.velocity *= -1;

          this.enemies.getChildren().forEach((bug) => {
            // TASK:
            // When leftmost or rightmost reaches edge, make each bug to
            // be vertically closer to player.
            bug.y += 5;
          })
        }
      }
    }

    // if(space.isDown)
    // if(time > this.recordedTime + 150)
    // {
    //   spawn.bugRepellents;
    //   this.recordedTime = time;
    // }
  }
};

const config = {
  type: Phaser.AUTO,
  width: 450,
  height: 500,
  backgroundColor: "b9eaff",
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { y: 0 },
      enableBody: true,
    }
  },
  scene: [GameScene]
}


const game = new Phaser.Game(config);
